pragma solidity ^0.4.18;
//TODO: Use safe math lib later 
contract Escrows {
      address public owner;
      uint32 public requestCancellationMinimumTime;
      uint16 public fee;//the rate of fee, fee/10000 is the acutall rate



    event Created(bytes32 _tradeHash, uint256 escrowId, address payer, address receiver, address arbitrator, uint256 value, uint16 rate);
    event SellerCancelDisabled(bytes32 _tradeHash);
    event CancelledBySeller(bytes32 _tradeHash);
    event CancelledByBuyer(bytes32 _tradeHash);
    event Released(bytes32 _tradeHash);
    event DisputeResolved(bytes32 _tradeHash);

    struct Escrow {
        uint256 escrowId; //uid of Escrow
        // Set so we know the trade has already been created
        bool exists;
        // The timestamp in which the seller can cancel the trade if the buyer has not yet marked as paid. Set to 0 on marked paid or dispute
        // 1 = unlimited cancel time
        // 0 = seller can not cancel
        uint32 sellerCanCancelAfter;

        address arbitrator;
        address payer; //who pay the ether on chain
        address receiver; //who finish job off chain
        uint256 value;//the wei payer need to pay

        //set true after apeal arbitration, then this trade will be locked and  only arbitrator can decide where the money go
        bool disputed;

        //rate/10000 is the fee arbitrator can get, this can be zero
        uint16 rate; 
    }
     // Mapping of active trades. Key is a hash of the trade data
    mapping (bytes32 => Escrow) public escrows;


    //Mapping of the score of the address as arbitrator
    mapping (address => uint256) public arbitratorScore;


    //Mapping of the score of the address as arbitrator
    mapping (address => uint256) public payerScore;

    //Mapping of the score of the address as receiver
    mapping (address => uint256) public receiverScore;



    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    modifier onlyEscrowExist(bytes32 _tradeHash) {
      require(escrows[_tradeHash].exists);
        _;
    }
    modifier onlyPayer(bytes32 _tradeHash) {
      require(msg.sender == escrows[_tradeHash].payer);
      _;
    }
    modifier onlyReceiver(bytes32 _tradeHash) {
      require(msg.sender == escrows[_tradeHash].receiver);
      _;
    }
    modifier onlyReceiverOrPayer(bytes32 _tradeHash) {
      require(msg.sender ==  escrows[_tradeHash].payer || msg.sender == escrows[_tradeHash].receiver);
      _;
    }
   

    function Escrows() public {
        /**
         * Initialize the contract.
         */
        owner = msg.sender;
        requestCancellationMinimumTime = 2 hours; // TODO
        fee = 50;
    }
    function isEscrowExist(bytes32 _tradeHash) view public returns(bool) {
        return escrows[_tradeHash].exists;
    }
     function getEscrowHash (
      /**
       * Hashes the values and returns the matching escrow object and trade hash.
       * Returns _tradeHash 
       */
      uint256 _escrowID,
      address _payer,
      address _receiver,
      address _arbitrator,
      uint256 _value,
      uint16 _rate
    ) pure public returns (bytes32) {
        bytes32 _tradeHash = keccak256(_escrowID, _payer, _receiver, _arbitrator, _value, _rate);
        return _tradeHash;
      }

      function getEscrowInfoByTradeHash(bytes32 _tradeHash) view public onlyEscrowExist(_tradeHash) returns(
         uint256 escrowId,
         address payer,
         address receiver,
         address arbitrator,
         uint256 value,
         bool disputed,
         uint16 rate

        )  {
          Escrow storage _escrow =  escrows[_tradeHash];
          escrowId = _escrow.escrowId;
          payer= _escrow.payer;
          receiver = _escrow.receiver;
          arbitrator = _escrow.arbitrator;
          value = _escrow.value;
          disputed = _escrow.disputed;
          rate = _escrow.rate;
      }
      //TODO: maybe need permission control here
     function createEscrow(
      /**
       * Create a new escrow and add it to `escrows`.
       * _tradeHash is created by hashing _escrowID, _payer, _receiver, _value and _fee variables. These variables must be supplied on future contract calls.
       * v, r and s is the signature data supplied from the api. The sig is keccak256(_tradeHash, _paymentWindowInSeconds, _expiry).
       */
      uint256 _escrowID, // The unique ID of the trade, generated by us
      address _payer, // The selling party of the trade
      address _receiver, // The buying party of the trade
      address _arbitrator,
      uint256 _value, // The ether amount being held in escrow
      uint32 _paymentWindowInSeconds, // The time in seconds from contract creation that the buyer has to mark as paid
      uint16 _rate //the rate/10000 is the arbitrator can receive
      //uint32 _expiry // Provided by localethereum.com. This transaction must be created before this time.
    ) payable external {
        bytes32 _tradeHash = keccak256(_escrowID, _payer, _receiver, _arbitrator, _value, _rate);
        require(!escrows[_tradeHash].exists); // Require that trade does not already exist
        require(msg.value == _value && msg.value > 0); // Check sent eth against signed _value and make sure is not 0
        uint32 _sellerCanCancelAfter = _paymentWindowInSeconds == 0 ? 1 : uint32(block.timestamp) + _paymentWindowInSeconds;
        escrows[_tradeHash] = Escrow(_escrowID, true, _sellerCanCancelAfter, _arbitrator, _payer, _receiver, _value, false, _rate);
        Created(_tradeHash, _escrowID, _payer, _receiver, _arbitrator, _value, _rate);
    }

   

    function doRelease(
      /**
       * Called by the seller to releases the funds for a successful trade.
       * Deletes the trade from the `escrows` mapping.
       */
      bytes32 _tradeHash
      //uint128 _additionalGas
    ) private onlyEscrowExist(_tradeHash) {
        //get this filed first so that it can still be accessed after delete
        address receiver = escrows[_tradeHash].receiver;
        uint256 value = escrows[_tradeHash].value;
        uint16 rate = escrows[_tradeHash].rate;

        delete escrows[_tradeHash];
        Released(_tradeHash);
        transferMinusFees(receiver, value, rate);

    }

    function doDisableSellerCancel(
      /**
       * Stops the seller from cancelling the trade.
       * Can only be called the buyer.
       * Used to mark the trade as paid, or if the buyer has a dispute.
       */
     bytes32 _tradeHash
      //uint128 _additionalGas
    ) private onlyEscrowExist(_tradeHash) {
        
        //0 means seller can not cancel
        //avoid do things twice
        require(escrows[_tradeHash].sellerCanCancelAfter != 0);
        //edit the original escrow in storage
        escrows[_tradeHash].sellerCanCancelAfter = 0;

        SellerCancelDisabled(_tradeHash);
        // if (msg.sender == relayer) {
        //   increaseGasSpent(_tradeHash, GAS_doDisableSellerCancel + _additionalGas);
        // }
    }


    function doBuyerCancel(
      /**
       * Cancels the trade and returns the ether to the seller.
       * Can only be called the buyer.
       */
      bytes32 _tradeHash
      //uint128 _additionalGas
    ) private onlyEscrowExist(_tradeHash) {
        address payer = escrows[_tradeHash].payer;
        uint256 value = escrows[_tradeHash].value;
       
        
       // uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer ? (GAS_doBuyerCancel + _additionalGas) * uint128(tx.gasprice) : 0);
        delete escrows[_tradeHash];
        CancelledByBuyer(_tradeHash);
        //refund the ether to seller
        //if cancel, arbitrator can not receive fee
        transferMinusFees(payer, value, 0);
    }

    // uint16 constant GAS_doSellerCancel = 36100;
    function doSellerCancel(
      /**
       * Cancels the trade and returns the ether to the seller.
       * Can only be called the seller.
       * Can only be called if the payment window was missed by the buyer
       */
     bytes32 _tradeHash
      //uint128 _additionalGas
    ) private onlyEscrowExist(_tradeHash) {
        address payer = escrows[_tradeHash].payer;
        uint256 value = escrows[_tradeHash].value;
      
        //if seller can not cancel, return false
        require( escrows[_tradeHash].sellerCanCancelAfter > 1 &&  escrows[_tradeHash].sellerCanCancelAfter < block.timestamp);
        //uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer ? (GAS_doSellerCancel + _additionalGas) * uint128(tx.gasprice) : 0);
        delete escrows[_tradeHash];
        CancelledBySeller(_tradeHash);
        //refund to seller
        //if cancel, arbitrator can not receive fee
        transferMinusFees(payer, value, 0);

    }

    function doAppealArbitration (
       /**
       * Appeal arbitration for this trade
       * Can only be called by seller or buyer
       */
       bytes32 _tradeHash
      ) private onlyEscrowExist(_tradeHash) {
      //avoid useless setting
      require(!escrows[_tradeHash].disputed);

        escrows[_tradeHash].disputed = true;
    }

    function resolveDispute(
      /**
       * Called by the arbitrator to resolve a dispute
       * Requires the signed ACTION_DISPUTE actionByte from either the buyer or the seller
       */
      bytes32 _tradeHash,
      bool  _isJobDone
    ) external onlyEscrowExist(_tradeHash) {
        //This should be memory because we need to use _escrow after it have been deleted

        Escrow memory _escrow = escrows[_tradeHash];
    
        require(msg.sender == _escrow.arbitrator);
        //can only arbitrate when trade is in disputed status
        require(_escrow.disputed == true);

        uint256 arbitratorFee = _escrow.value * _escrow.rate /10000;
        uint256 _totalFees = arbitratorFee + (_escrow.value * fee / 10000);

        //uint256 _totalFees =  GAS_doResolveDispute;
       require(_escrow.value - _totalFees <= _escrow.value); // Prevent underflow
       //feesAvailableForWithdraw += _totalFees; // Add the the pot for localethereum to withdraw

        //must delete first to avoid replay attack
        delete escrows[_tradeHash];
        DisputeResolved(_tradeHash);
        

       
       
       uint256 fund = _escrow.value - _totalFees ;
        if(_isJobDone) {
          _escrow.receiver.transfer(fund);
        } else {
          _escrow.payer.transfer(fund);
        }

        //arbitrator need to refund
        _escrow.arbitrator.transfer(arbitratorFee);


        
    }

    function release(bytes32 _tradeHash) 
    external onlyPayer(_tradeHash) {
      doRelease(_tradeHash);
    }
    function disableSellerCancel(bytes32 _tradeHash) 
    external onlyReceiver(_tradeHash) {
      doDisableSellerCancel(_tradeHash);
    }


    function buyerCancel(bytes32 _tradeHash) external onlyReceiver(_tradeHash) {
      doBuyerCancel(_tradeHash);
    }

    function sellerCancel(bytes32 _tradeHash) external onlyPayer(_tradeHash) {
      doSellerCancel(_tradeHash);
    }

    function appealArbitration(bytes32 _tradeHash) external onlyReceiverOrPayer(_tradeHash) {
      doAppealArbitration(_tradeHash);
    }

    function changeFee(uint16 _fee) public onlyOwner {
      //avoid overflow
      require(fee > 0 && fee < 10000);
      fee = _fee;
    }


    //minus fee for platform and rate for arbitrator
     function transferMinusFees(address _to, uint256 _value, uint16 _rate) private {
        uint256 _totalFees = (_value * _rate / 10000) + (_value * fee / 10000);
        if(_value - _totalFees > _value) return; // Prevent underflow
        //feesAvailableForWithdraw += _totalFees; // Add the the pot for localethereum to withdraw
        _to.transfer(_value - _totalFees);
    }

    function withdraw(address _to) public onlyOwner {
      require(_to != address(0));
      _to.transfer(this.balance);
    }






}